// Generated by CoffeeScript 1.6.3
var Source, coffee, fs, mkdirp, path, sourcemap, uglify, xcolor;

fs = require('fs');

path = require('path');

mkdirp = require('mkdirp');

xcolor = require('xcolor');

coffee = require('coffee-script');

uglify = require('uglify-js');

sourcemap = require('source-map');

Source = (function() {
  function Source(options, file, inputPath) {
    this.options = options;
    this.file = file != null ? file : "";
    this.inputPath = inputPath != null ? inputPath : "";
    this.writeTime = 0;
    this.compileTime = 0;
    this.modTime = 0;
    this.inputPath || (this.inputPath = this.file);
    if (this.file) {
      this.inputFile = path.resolve(file);
      this.read();
    }
  }

  Source.prototype.read = function() {
    this.src = fs.readFileSync(this.file, 'utf8');
    this.lines = this.src.split('\n').length;
    this.modTime = new Date().getTime();
    return this.setOutputPath();
  };

  Source.prototype.compile = function() {
    var err;
    try {
      this.error = false;
      this.compiled = coffee.compile(this.src, this.getCompileOptions());
      this.compileTime = new Date().getTime();
      if (this.compiled.js != null) {
        this.sourceMap = JSON.parse(this.compiled.v3SourceMap);
        return this.compiled = this.compiled.js;
      }
    } catch (_error) {
      err = _error;
      this.error = err.toString();
      this.errorFile = this.file;
      return this.errorLine = err.location.first_line;
    }
  };

  Source.prototype.minify = function() {
    var result;
    result = uglify.minify(this.compiled, {
      fromString: true
    });
    return this.compiled = result.code;
  };

  Source.prototype.write = function() {
    this.setOutputPath();
    mkdirp.sync(path.dirname(this.outputPath));
    fs.writeFileSync(this.outputPath, this.compiled, 'utf8');
    this.writeTime = new Date().getTime();
    if (this.options.sourceMap && this.options.output && !this.options.join) {
      this.writeMapSource();
    }
    if (!this.options.silent) {
      return xcolor.log("  " + ((new Date).toLocaleTimeString()) + " - {{.boldCoffee}}Compiled{{/color}} {{.coffee}}" + this.outputPath);
    }
  };

  Source.prototype.writeSource = function(base) {
    var outputPath;
    outputPath = path.join(base, this.file);
    mkdirp.sync(path.dirname(outputPath));
    return fs.writeFileSync(outputPath, this.src, 'utf8');
  };

  Source.prototype.writeMapSource = function() {
    var mapOutput;
    mapOutput = this.outputPath.replace('.js', '.coffee');
    return fs.writeFileSync(mapOutput, this.src, 'utf8');
  };

  Source.prototype.writeMapComment = function(map) {
    var commentMap;
    map || (map = JSON.stringify(this.sourceMap));
    commentMap = new Buffer(map).toString('base64');
    commentMap = "//@ sourceMappingURL=data:application/json;base64," + commentMap;
    return this.compiled = "" + this.compiled + "\n" + commentMap;
  };

  Source.prototype.writeMapCommentExt = function(map) {
    var commentMap, mapName, mapOutput;
    mkdirp.sync(path.dirname(this.outputPath));
    mapOutput = this.outputPath.replace('.js', '.map');
    map || (map = JSON.stringify(this.sourceMap));
    fs.writeFileSync(mapOutput, map, 'utf8');
    mapName = path.basename(mapOutput);
    commentMap = "//@ sourceMappingURL=" + mapName;
    return this.compiled = "" + this.compiled + "\n" + commentMap;
  };

  Source.prototype.getCompileOptions = function() {
    return {
      header: this.options.header,
      bare: this.options.bare,
      literate: this.isLiterate(),
      filename: this.file,
      sourceMap: this.options.sourceMap,
      sourceFiles: [this.options.join ? this.file : path.basename(this.file)],
      generatedFile: this.outputPath
    };
  };

  Source.prototype.isLiterate = function() {
    return /\.(litcoffee|coffee\.md)$/.test(this.file);
  };

  Source.prototype.reportError = function() {
    return xcolor.log("  " + ((new Date).toLocaleTimeString()) + " - {{bold}}{{.error}}" + this.errorFile + ":{{/bold}} " + this.error + " on line " + (this.errorLine + 1));
  };

  Source.prototype.setOutputPath = function() {
    var base, baseDir, baseFragment, baseInputDir, baseOutputDir, dir, fileName;
    if (this.outputPath) {
      return;
    }
    base = path.basename(this.file);
    base = base.substr(0, base.indexOf('.'));
    fileName = base + '.js';
    dir = path.dirname(this.file);
    if (this.options.output) {
      if (this.inputPath[0] === path.sep) {
        baseInputDir = this.inputPath.replace('**/*.{coffee,litcoffee,coffee.md}', '');
        baseInputDir = baseInputDir.replace(new RegExp("" + (path.basename(baseInputDir)) + "/?$"), '');
        baseInputDir = path.normalize(baseInputDir);
        baseOutputDir = dir.replace(baseInputDir, '');
        baseFragment = baseOutputDir.substr(0, baseOutputDir.indexOf(path.sep));
        baseDir = baseOutputDir.replace(new RegExp("^" + baseFragment), '');
        dir = baseFragment ? path.join(this.options.output, baseDir) : this.options.output;
      } else if (this.inputPath.indexOf(path.sep)) {
        baseDir = this.inputPath.substr(0, this.inputPath.indexOf(path.sep));
        dir = dir.replace(new RegExp("^" + baseDir), this.options.output);
      } else {
        dir = this.options.output;
      }
    }
    return this.outputPath = path.join(dir, fileName);
  };

  Source.prototype.updated = function() {
    return this.modTime >= this.compileTime;
  };

  Source.prototype.outputReady = function() {
    return !this.error && this.compileTime >= this.writeTime;
  };

  return Source;

})();

module.exports = Source;
